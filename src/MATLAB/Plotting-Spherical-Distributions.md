The following typical spherical distributions are plotted by the [GNU Octave](http://www.octave.org) which is an open source alternative to [MATLAB](https://www.mathworks.com/help/matlab/index.html).  

## NDF GGX  

```MATLAB
# user-interface roughness parameter
r = 0.5;

# Physically Based Shading at Disney
# α = r2
alpha = r * r;
alpha2 = alpha * alpha;

# H = [H_x, H_y, H_z] is the half vector, namely, the micro normal
# Usually, H is the 'm' in the NDF formulation
# And H is treated as the domain of the spherical distribution
[H_x, H_y, H_z] = sphere (256 - 1);

# H is in the tangent space where the N is (0, 0, 1)
NoH = H_z;

# χ is the positive characteristic function
# chi = heaviside(NoH);
chi = cast (NoH > 0, class (NoH));

# https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/BRDF.ush#L318
# https://www.mathworks.com/help/matlab/matlab_prog/array-vs-matrix-operations.html
d = 1.0 + NoH .* (NoH .* alpha2 - NoH);
D = alpha2 ./ (pi .* d .* d);
D = chi .* D;

# plot
# surf(D .* H_x, D .* H_y, D .* H_z);
mesh(D .* H_x, D .* H_y, D.* H_z);
axis equal;
title ("NDF GGX");
```  

![](NDF-GGX.png)  

## G1 GGX  

```MATLAB
# user-interface roughness parameter
r = 0.5;

# Physically Based Shading at Disney
# α = r2
alpha = r * r;
alpha2 = alpha * alpha;

# V = [V_x, V_y, V_z] is the outgoing direction
# Usually, V is the 'ω_o' in the G formulation
# And V is treated as the domain of the spherical distribution
[V_x, V_y, V_z] = sphere (256 - 1);

# V is in the tangent space where the N is (0, 0, 1)
NoV = V_z;

# technically, H is the micro normal while N is the macro normal
HoV = NoV;

# χ is the positive characteristic function
# chi = heaviside(HoV);
chi = cast (HoV > 0, class (HoV));

# Equation 9.37 of Real-Time Rendering Fourth Edition
a2 = NoV .* NoV ./ (alpha2 .* (1.0 - NoV .* NoV));

# The Λ function
# Equation 9.42 of Real-Time Rendering Fourth Edition  
lambda = 0.5 * (-1.0 + sqrt(1.0 + 1.0 ./ a2));

# The G1 function
# Equation 9.24 of Real-Time Rendering Fourth Edition  
G1 = 1.0 ./ (1.0 + lambda);
G1 = chi .* G1;

# plot
# surf(G1 .* V_x, G1 .* V_y, G1 .* V_z);
mesh(G1 .* V_x, G1 .* V_y, G1 .* V_z);
axis equal;
title ("G1 GGX");
```  

![](G1-GGX.png)  

## Weak White Furnace Test GGX  

```MATLAB
# user-interface roughness parameter
r = 0.5;

# Physically Based Shading at Disney
# α = r2
alpha = r * r;
alpha2 = alpha * alpha;

# V = [V_x, V_y, V_z] is the outgoing direction
# Usually, V is the 'ω_o' in the G formulation
# And V is treated as the domain of the spherical distribution
numV = 32 - 1;
[V_x, V_y, V_z] = sphere (numV);

# TODO: use the vector operation to replace the for loop 
parfor r = 1:numV
parfor c = 1:numV

V = [V_x(r, c) V_y(r, c) V_z(r, c)];

# V is in the tangent space where the N is (0, 0, 1)
NoV = V(3);

# Equation 9.37 of Real-Time Rendering Fourth Edition
a2 = NoV .* NoV ./ (alpha2 .* (1.0 - NoV .* NoV));

# The Λ function
# Equation 9.42 of Real-Time Rendering Fourth Edition  
lambda = 0.5 * (-1.0 + sqrt(1.0 + 1.0 ./ a2));

# The G1 function
# Equation 9.24 of Real-Time Rendering Fourth Edition  
G1 = 1.0 ./ (1.0 + lambda);

# L = [L_x, L_y, L_z] is the incident direction
# Usually, L is the 'ω_i' in the BRDF formulation
numSamples = 1024 - 1;
[L_x, L_y, L_z] = sphere (numSamples);

# d_L is the corresponding surface area of the unit sphere 
# Usually, d_L is the 'dω_i' in the integral formulation 
# The result is NOT correct since the area of the faces generated by the 'sphere' function is NOT the same
d_L = (4.0 * pi / numSamples / numSamples);

# H = [H_x, H_y, H_z] is the half vector, namely, the micro normal
# Usually, H is the 'm' in the NDF formulation
H_x = V(1) + L_x;
H_y = V(2) + L_y;
H_z = V(3) + L_z;
H_norm = sqrt(H_x .* H_x + H_y .* H_y + H_z .* H_z);
H_x = H_x ./ H_norm;
H_y = H_y ./ H_norm;
H_z = H_z ./ H_norm;

# H is in the tangent space where the N is (0, 0, 1)
NoH = H_z;

# χ is the positive characteristic function
# chi = heaviside(NoH);
chi = cast (NoH > 0, class (NoH));

# https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/BRDF.ush#L318
d = 1.0 + NoH .* (NoH .* alpha2 - NoH);
D = alpha2 ./ (pi .* d .* d);

absNoV(NoV > 0) = NoV;
absNoV(NoV <= 0) = -NoV;

intMat = chi .* G1 .* D ./ (4 .* absNoV) .* d_L;

int = sum(sum(intMat));

end
end

# VoL = V(1) .* L_x + V(2) .* L_y + V(3) .* L_z; 
# chi = cast (VoL > 0.999, class (VoL));
# VoL = chi .* VoL;
# mesh(VoL .* L_x, VoL .* L_y, VoL .* L_z);
# axis equal;
# title ("Test V");

# plot
# surf(D_GGX .* L_x, D_GGX .* L_y, D_GGX .* L_z);
# mesh(integral .* L_x, integral .* L_y, integral .* L_z);
# axis equal;
# title ("Test V");
```