# LTC (Linearly Transformed Cosine)  

## 1\. Clamped Cosine Integral  
### 1-1\. Clamped Cosine  
We assume that the normal direction in the tangent space is (0, 0, 1), which is called the **Median Vector** in \[Heitz 2016\]. The **clamped cosine** is defined as $\displaystyle \operatorname{D_o}(\omega_o) = \frac{1}{\pi} |\cos \theta_o| = \frac{1}{\pi} | \overrightarrow{(0,0,1)} \cdot \overrightarrow{\omega_o}| = \frac{1}{\pi} \max(0, z)$ where $\displaystyle \overrightarrow{\omega_o} = (x, y, z)$. Evidently, by [the Figure 5.13 of the PBR Book](https://pbr-book.org/3ed-2018/Color_and_Radiometry/Working_with_Radiometric_Integrals#IntegralsoverProjectedSolidAngle), we have $\displaystyle \int_\Omega \operatorname{D_o} \, d\omega_o = \frac{1}{\pi} \int_\Omega |\cos \theta_o| \, d\omega_o = \frac{1}{\pi} \int_\Omega 1 \, d\omega_o^{\perp} = \frac{1}{\pi} \cdot \pi = 1$, and thus $\displaystyle \operatorname{D_o}$ is normalized.  

### 1-2\. Integral over the Polygon  
We assume that the vertices $\displaystyle \overrightarrow{p_1}, \overrightarrow{p_2}, \ldots, \overrightarrow{p_n}$ of the polygon $\displaystyle P_o$ are in the tangent space, normalized, and located in the upper hemisphere. By \[Heitz 2017\], the clamped cosine integral over the polygon $\displaystyle \operatorname{F}(P_o) = \int_{P_o} \operatorname{D_o} \, d\omega_o$ is closed-form $\displaystyle \operatorname{F}(P_o) = \frac{1}{2\pi} \sum_{i \, j}^n \arccos(\overrightarrow{p_i} \cdot \overrightarrow{p_j}) (\operatorname{normalize}(\overrightarrow{p_i} \times \overrightarrow{p_j}) \cdot \overrightarrow{(0, 0, 1)})$. Note that the **winding order** of the vertices implies the direction of the resulting vector $\displaystyle \overrightarrow{p_i} \times \overrightarrow{p_j}$ and thus the facing of the polygon.  
Actually, the clamped cosine integral over the polygon $\displaystyle \operatorname{F}(P_o)$ is called the **form factor**. The terms **irradiance** and **form factor** may be interchangeably used. But technically, the **irradiance** should NOT be divided by $\displaystyle \pi$. This means that $\displaystyle \operatorname{E}(P_o) = \pi \operatorname{F}(P_o)$.  

However, the assumption, that the vertices are in the upper hemisphere, forces us to clip the polygon. This introduces [divergent branches](https://docs.nvidia.com/gameworks/content/developertools/desktop/analysis/report/cudaexperiments/sourcelevel/divergentbranch.htm) which should ideally be avoided.  

Actually, by [Snyder 1996], the integral over the sphere can be calculated without clipping as $\displaystyle F = \frac{1}{\pi} {\begin{cases} {\displaystyle \pi \cos \omega \sin^2 \sigma} &{\displaystyle \omega \isin [0, \frac{\pi}{2} - \sigma]} \\{\displaystyle \pi \cos \omega \sin^2 \sigma + \operatorname{G}(\omega, \sigma, \gamma) - \operatorname{H}(\omega, \sigma, \gamma)} &{\displaystyle \omega \isin [\frac{\pi}{2} - \sigma, \frac{\pi}{2}]} \\{\operatorname{G}(\omega, \sigma, \gamma) - \operatorname{H}(\omega, \sigma, \gamma)} &{\displaystyle \omega \isin [\frac{\pi}{2}, \frac{\pi}{2} + \sigma]} \\{0} &{\omega \isin [\frac{\pi}{2} + \sigma, {\pi}]} \end{cases}}$ where $\displaystyle \omega$ is the **elevation angle** and $\displaystyle \sigma$ is the **angular extent**. Evidently, this formulation can precomputed and stored in a 2D LUT which is indexed by $\displaystyle \cos \omega$ and $\displaystyle \sin \sigma$.  And by [Stephen 2016], using the linear fit, this formulation can be approximated by $\displaystyle F = \sin^2 \sigma \frac{\sin^2 \sigma + \cos \omega}{\sin^2 \sigma + 1}$. Evidently, this approximation can be calculated in real time.  
The integral over the sphere is calcualted by the [genSphereTab](https://github.com/selfshadow/ltc_code/blob/master/fit/fitLTC.cpp#L307) in the WebGL Demo provided by \[Stephen 2016\], [PolygonIrradianceFromVectorFormFactor](https://github.com/Unity-Technologies/Graphics/blob/v10.8.0/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl#L1630) in Unity3D, and [SphereHorizonCosWrap](https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/CapsuleLight.ush#L95) in UE4.

By [Stephen 2016], the **vector form factor** over the polygon can be calculated as $\displaystyle \overrightarrow{\operatorname{F}}(P_o) = \frac{1}{2\pi} \sum_{i \, j}^n \arccos(\overrightarrow{p_i} \cdot \overrightarrow{p_j}) \operatorname{normalize}(\overrightarrow{p_i} \times \overrightarrow{p_j})$ even if the vertices are NOT in the upper hemisphere. The term **vector form factor** is analogous to the term **vector irradiance** of which the direction is the direction where a flat surface can receive the highest irradiance.  
And the vector form factor over the sphere is the vector of which the direction is towards the center of the sphere and the length is $\displaystyle F = \frac{1}{\pi} \int_0^{2\pi} \int_0^\alpha \cos \theta \sin \theta \, d \theta d \phi  = \sin^2(\sigma)$ where $\displaystyle \sigma$ is the angular extent. Thus, a proxy sphere with the same vector form factor can be introduced. This proxy sphere can be used to calculate the integral over the polygon without clipping according to the formulation by [Snyder 1996].  
The clamped cosine integral over the polygon $\displaystyle \operatorname{F}(P_o)$ is calculated by the [LTC_Evaluate](https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_quad.fs#L274) in the WebGL Demo provided by \[Stephen 2016\], [EvaluateBSDF_Rect](https://github.com/Unity-Technologies/Graphics/blob/v10.8.0/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl#L1764) in Unity3D, and [RectIrradianceLambert](https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/RectLight.ush#L108) and [RectGGXApproxLTC](https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/RectLight.ush#L442) in UE4.  

## 2\. LTC  
### 2-1\. LTSD   
We assume that M is the linear transform matrix, and $\displaystyle \omega = \operatorname{normalize}(M \omega_o)$.  For the arbitrary **original distribution** $\displaystyle \operatorname{D_o}(\omega_o)$, the corresponding **LTSD \(linearly transformed spherical distribution\)** $\displaystyle \operatorname{D}(\omega)$ is defined as $\displaystyle \operatorname{D}(\omega) = \operatorname{D_o}(\omega_o) \frac{d\omega_o}{d\omega}$. Evidently, we have $\displaystyle \omega_o = \operatorname{normalize}(M^{-1} \omega)$. And the relationship between $\displaystyle d\omega_o$ and $\displaystyle d\omega$ is closed-form $\displaystyle \frac{d\omega_o}{d\omega} = \frac{|M^{-1}|}{{\|M^{-1}w\|}^3}$. The proof of this closed-form formula is provided in **Appendix A** of \[Heitz 2016\]. Note that $\displaystyle \omega_o$ and $\displaystyle \omega$ are **vectors** which represent the **direction**, while $\displaystyle d\omega_o$ and $\displaystyle d\omega$ are **solid angles** which represent the **area** on the **sphere surface**. By [the Equation (5.6) of the PBR Book](https://pbr-book.org/3ed-2018/Color_and_Radiometry/Working_with_Radiometric_Integrals#IntegralsoverArea), we have $\displaystyle d\omega = \frac{(A d\omega_o) \cos\theta}{r^2}$ where the A is the ratio, and the $\displaystyle A d\omega_o$ is the area subtended by the solid angle $\displaystyle d\omega$.  

### 2-2\. LTC  
When the **clamped cosine** $\displaystyle \operatorname{D_o}(\omega_o) = \frac{1}{\pi} |\cos \theta_o|$ is used as the **original distribution** $\displaystyle \operatorname{D_o}(\omega_o)$, the corresponding **LTSD \(linearly transformed spherical distribution\)** $\displaystyle \operatorname{D}(\omega)$ is called the **LTC \(linearly transformed cosine\)**.  

### 2-3\. Shading with Constant Polygonal Lights  
When the $\displaystyle \operatorname{L_l}(\omega_l)$ is assumed to be constant $\displaystyle L_l$, we have $\displaystyle \operatorname{L_v}(\omega_v) = \int_{P} \operatorname{BRDF}(\omega_v, \omega_l) \operatorname{L_l}(\omega_l) |\cos \theta_l| \, d\omega_l = L_l \int_{P} \operatorname{BRDF}(\omega_v, \omega_l) |\cos \theta_l| \, d\omega_l$.  

## 3\. Approximation  
### 3-1\. Approximation GGX
By the "Equation (5.9)" of the [PBR Book](https://pbr-book.org/3ed-2018/Color_and_Radiometry/Surface_Reflection#TheBRDF), we have $\displaystyle \operatorname{L_v}(\omega_v) = \int_{P} \operatorname{f}(\omega_v, \omega_l) \operatorname{L_l}(\omega_l) |\cos \theta_l| \, d\omega_l$. And we use **non-linear optimization** to approximate the BRDF cosine by LTC. The [fitting](https://github.com/selfshadow/ltc_code/blob/master/fit/fitLTC.cpp) code  

### 3-1\. LUT UV
Since the GGX BRDF is isotropic, the distribution can be determined by the outgoing direction $\displaystyle \omega_v$ and the roughness $\displaystyle \alpha$, which are used as the UV of the LUTs. 

### 3-2\. Tangent Space  
Note that the LUTs are precomputed by assuming that the vectors are in the tangent space where the normal direction is assumed to be the Z axis (0, 0, 1), and since the GGX BRDF is isotropic, the outgoing direction $\displaystyle \omega_v$ is assumed to be in the XOZ plane. Thus, the vectors should be transformed to this tangent space before the approximation is applied.  

### 3-3\. LUT M
Actually, when M is the scaling transformation $\displaystyle M = \lambda I$, we have $\displaystyle \frac{d\omega_o}{d\omega} = \frac{|M^{-1}|}{{\|M^{-1}w\|}^3} = \frac{\frac{1}{{\lambda}^3}}{{(\frac{1}{\lambda})}^3} = 1$, and thus the LTSC is scale invariant. And since GGX BRDF is planar symmetry and isotropic, by \[Heitz 2016\], the M can be represented by only 4 parameters. The the inverse $\displaystyle M^{-1} = \begin{bmatrix} 1 & 0 & G \\ 0 & B & 0 \\ A & 0 & R \end{bmatrix}$, which is used when rendering, is stored in the LUT. This LUT is called the [ltc_1](https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_quad.fs#L26) in the WebGL Demo provided by \[Stephen 2016\].  

### 3-4\. LUT Norm
By [Integration by Substitution](https://en.wikipedia.org/wiki/Integration_by_substitution), we can comprehend intuitively that $\displaystyle \int_{\Omega} \operatorname{D}(\omega) \, d\omega = \int_{\Omega} \operatorname{D_o}(\omega_o) \frac{d\omega_o}{d\omega} d\omega = \int_{\Omega} \operatorname{D_o}(\omega_o) d\omega_o = 1$. Since the **clamped cosine** is normalied, the LTCs must be normalized.  However, $\displaystyle \operatorname{f}(\overrightarrow{\omega_v}, \overrightarrow{\omega_l})|\cos \theta_l|$ is **NOT** normalized. And thus the **norm** $\displaystyle \operatorname{n}(\overrightarrow{\omega_v}) = \int_{\Omega} \operatorname{f}(\overrightarrow{\omega_v}, \overrightarrow{\omega_l})|\cos \theta_l| \, d\omega_l$ should be introduced to accomplish the approximation. This means that $\displaystyle \operatorname{f}(\overrightarrow{\omega_v}, \overrightarrow{\omega_l})|\cos \theta_l| \approx \operatorname{n}(\overrightarrow{\omega_v}) \operatorname{D}(\omega_l)$.  
Actually, according to "Equation (9.9)" of [Real-Time Rendering Fourth Edition](https://www.realtimerendering.com/), the **norm** is the HDR (hemispherical directional reflectance). Analogous to the "Equation (9)" of \[Karis 2013\], the [LTC Fresnel Approximation](https://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf) of \[Stephen 2016\] proposed that the Fresnel term is treated separately, and we have $\displaystyle \operatorname{R}(\overrightarrow{\omega_v}) = \int_\Omega [F_0 + (F_{90} - F_0) {(1.0 - \overrightarrow{\omega_v} \cdot \overrightarrow{\omega_h})}^5] \operatorname{DV}(\overrightarrow{\omega_l}, \overrightarrow{\omega_v}) \, d \omega_l = F_0 \cdot \operatorname{n_R}(\overrightarrow{\omega_v}) + (F_{90} - F_0) \cdot \operatorname{n_G}(\overrightarrow{\omega_v})$ where $\displaystyle  \operatorname{n_R}(\overrightarrow{\omega_v}) = \int_\Omega  \operatorname{DV}(\overrightarrow{\omega_l}, \overrightarrow{\omega_v}) \, d \omega_l$ and $\displaystyle \operatorname{n_G}(\overrightarrow{\omega_v}) = \int_\Omega {(1.0 - \overrightarrow{\omega_v} \cdot \overrightarrow{\omega_h})}^5 \operatorname{DV}(\overrightarrow{\omega_l}, \overrightarrow{\omega_v}) \, d \omega_l$. Evidently, $\displaystyle \operatorname{n_R}(\overrightarrow{\omega_v})$ and $\displaystyle \operatorname{n_G}(\overrightarrow{\omega_v})$ can be stored in the LUT.  
But we can use the same formluation as \[Karis 2013\], and the same LUT can be used. The LUT of \[Stephen 2016\] is called the [ltc_2](https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_quad.fs#L26) in the WebGL Demo provided by \[Heitz 2016\] and [LTCAmpTexture](https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/RectLight.ush#L437) in UE4. And the LUT of \[Karis 2013\] is called [PreIntegratedGF](https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/BRDF.ush#L467) in UE4 and [_PreIntegratedFGD_GGXDisneyDiffuse](https://github.com/Unity-Technologies/Graphics/blob/v10.8.0/com.unity.render-pipelines.high-definition/Runtime/Material/PreIntegratedFGD/PreIntegratedFGD.hlsl#L3) in Unity3D.  

## 4\. Light

### 4-1\. Integration over Polygons
By [Integration by Substitution](https://en.wikipedia.org/wiki/Integration_by_substitution), we can comprehend intuitively that $\displaystyle \int_{P} \operatorname{D}(\omega) \, d\omega = \int_{P} \operatorname{D_o}(\omega_o) \frac{d\omega_o}{d\omega} d\omega = \int_{P_o} \operatorname{D_o}(\omega_o) d\omega_o$ where $\displaystyle P_o = M^{-1} P$. Evidently, $\displaystyle P_o = \operatorname{normalize}(M^{-1} P)$ is more consistent with $\displaystyle \omega_o = \operatorname{normalize}(M^{-1} \omega)$. However, even if the $\displaystyle M^{-1} P$ is **NOT** normalized, the area on the sphere surface subtended by the polygon remains the same. Thus, the normalize operator is **NOT** necessary here. Actually, the normalize operator will eventually be applied when the irradiance $\displaystyle \operatorname{E}(P_o)$ is calculated by \[Heitz 2017\].  

### 4-2\. Shading with Constant Polygonal Lights  

By **2\. Approximation**, we have $L_l \int_{P} \operatorname{BRDF}(\omega_v, \omega_l) |\cos \theta_l| \, d\omega_l \approx L_l \int_{P} \mathrm{NormBRDFCosine} \cdot \operatorname{D}(\omega_l) \, d\omega_l = L_l \cdot \mathrm{NormBRDFCosine} \cdot \int_{P} \operatorname{D}(\omega_l) \, d\omega_l$. Note that the polygon P should be transformed to the tangent space before the approximation is applied.  
And by **3-1\. Integration over Polygons**, we have $\displaystyle  L_l \cdot \mathrm{NormBRDFCosine} \cdot \int_{P} \operatorname{D}(\omega_l) \, d\omega_l = L_l \cdot \mathrm{NormBRDFCosine} \cdot \int_{P_o} \operatorname{D_o}(\omega_o) \, d\omega_o = L_l \cdot \mathrm{NormBRDFCosine} \cdot \operatorname{E}(P_o)$ where $\displaystyle P_o = M^{-1} P$ and $\displaystyle \operatorname{E}(P_o) = \int_{P_o} \operatorname{D_o}(\omega_o) \, d\omega_o = \int_{P_o} \frac{1}{\pi}|\cos \theta_o| \, d\omega_o$.  

## References  
\[Snyder 1996\] [John Snyder. "Area Light Sources for Real-Time Graphics." Technical Report 1996](https://www.microsoft.com/en-us/research/publication/area-light-sources-for-real-time-graphics/)  
\[Karis 2013\] [Brian Karis. "Real Shading in Unreal Engine 4." SIGGRAPH 2013.](https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf)  
\[Heitz 2016\] [Eric Heitz, Jonathan Dupuy, Stephen Hill, David Neubelt. "Real-Time Polygonal-Light Shading with Linearly Transformed Cosines." SIGGRAPH 2016.](https://eheitzresearch.wordpress.com/415-2/)  
\[Stephen 2016\] [Stephen Hill, Eric Heitz. "Real-Time Area Lighting: a Journey from Research to Production." SIGGRAPH 2016.](https://blog.selfshadow.com/publications/s2016-advances/)  
\[Heitz 2017\] [Eric Heitz. "Geometric Derivation of the Irradiance of Polygonal Lights." Technical report 2017.](https://hal.archives-ouvertes.fr/hal-01458129)  
